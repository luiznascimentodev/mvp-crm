# üó∫Ô∏è Roadmap: Orbit CRM (NestJS Enterprise Edition)

> **Vis√£o do Projeto:** Uma plataforma de CRM com arquitetura de **Mon√≥lito Modular** baseada em **NestJS**, simulando um ambiente corporativo real. O sistema utiliza **Seguran√ßa Ofensiva**, **Processamento Ass√≠ncrono**, **Colabora√ß√£o em Tempo Real** e **Type-Safety Ponta a Ponta**.

**Estrat√©gia de Versionamento:**

- **Conventional Commits:** `feat:`, `fix:`, `docs:`, `chore:`, `test:`, `ops:`.
- **Atomicidade:** Commits pequenos que contam a hist√≥ria da constru√ß√£o passo a passo.

---

## üíé Pilares T√©cnicos & Par√¢metros de Mercado

1.  **Arquitetura NestJS (Opinionated):** Uso estrito de M√≥dulos, Controllers, Services e Inje√ß√£o de Depend√™ncia (DI).
2.  **Type-Safety Ponta a Ponta:** O Frontend usa um **SDK gerado automaticamente** a partir do Swagger do Backend.
3.  **Storage Seguro:** Uploads via **Presigned URLs** diretas para S3/MinIO.
4.  **Assincronicidade:** Workers dedicados (BullMQ) para tarefas pesadas.
5.  **Qualidade Assegurada (QA):** TDD com Vitest e E2E com Playwright.

---

## üõ†Ô∏è Tech Stack "State-of-the-Art" (Dezembro 2025)

| Camada        | Tecnologia     | Vers√£o       | Justificativa de Mercado             |
| :------------ | :------------- | :----------- | :----------------------------------- |
| **Runtime**   | **Node.js**    | **v24.12.0** | Estabilidade LTS.                    |
| **Framework** | **NestJS**     | **v11.0**    | Padr√£o Enterprise.                   |
| **Adapter**   | **Fastify**    | **v5.x**     | Performance HTTP.                    |
| **Database**  | **PostgreSQL** | **v17.2**    | ACID Compliance.                     |
| **ORM**       | **Prisma**     | **v6.16.0**  | Type-safety.                         |
| **Frontend**  | **React**      | **v19.2**    | React Compiler.                      |
| **SDK Gen**   | **Hey API**    | **Latest**   | Gera√ß√£o de Client Fetch via Swagger. |
| **Async**     | **BullMQ**     | **v5.12**    | Filas Redis.                         |
| **Tests**     | **Playwright** | **Latest**   | E2E Tests.                           |

---

## üö© Milestone 0: Funda√ß√£o, Arquitetura e Ambiente Seguro

**Objetivo:** Base s√≥lida com estrutura Modular do NestJS e Tooling.

- [x] **0.1 Setup do Monorepo (Workspaces)**
  - Inicializar Git.
  - Criar `package.json` raiz com workspaces: `["server", "web"]`.
  - Criar pasta `/server` (`nest new server`).
  - Criar pasta `/web` (`npm create vite@latest web`).
- [x] üíæ **COMMIT:** `chore: init monorepo structure with npm workspaces`
- [x] **0.2 Tooling & Linting**
  - Configurar ESLint 9 (Flat Config) na raiz.
  - Configurar Prettier e `.editorconfig`.
  - Configurar Husky e Commitlint.
- [x] üíæ **COMMIT:** `chore: configure strict eslint, prettier and husky`
- [x] **0.2.1 üìä Diagrama de Casos de Uso**
  - Mapear funcionalidades principais (Auth, Contacts, Pipeline, Teams).
  - Definir atores (Admin, Manager, Seller).
  - Criar diagrama UML (PlantUML ou Mermaid).
- [x] üíæ **COMMIT:** `docs: add use case diagram`
- [x] **0.3 üõ°Ô∏è Hardening & Config**
  - Configurar `ConfigModule` com valida√ß√£o **Zod**.
  - Configurar `FastifyAdapter` e `helmet`.
  - **Global Filter:** Criar `AllExceptionsFilter` para padronizar erros JSON (RFC 7807).
- [x] üíæ **COMMIT:** `feat: setup security headers and global error handling`
- [x] **0.4 Dockeriza√ß√£o (Infra Local)**
  - Criar `docker-compose.yml`: Postgres, Redis, MinIO.
- [x] üíæ **COMMIT:** `ops: add docker-compose for local development`
- [x] **0.5 üìä Logging (Observabilidade)**
  - Instalar **Pino** (`npm i pino pino-http pino-pretty nestjs-pino`).
  - Criar `LoggerModule` e `LoggerService` customizado:
    - Configurar n√≠veis de log por ambiente (dev: debug, prod: info).
    - Habilitar pretty-print em desenvolvimento.
    - Logs estruturados em JSON para produ√ß√£o.
  - Implementar `LoggingInterceptor` global:
    - Logar todas as requisi√ß√µes HTTP (m√©todo, URL, status, dura√ß√£o).
    - Adicionar `correlationId` (UUID) em cada request para rastreamento.
    - Capturar IP do cliente e User-Agent.
  - Integrar com `AllExceptionsFilter`:
    - Logar stack trace completo de erros.
    - Incluir contexto da requisi√ß√£o (IP, m√©todo, rota, headers).
  - Adicionar logs contextuais em pontos cr√≠ticos:
    - In√≠cio/fim de opera√ß√µes do sistema.
    - Performance de queries lentas (threshold: >500ms).
    - Nota: Logs de autentica√ß√£o e contexto de usu√°rio ser√£o adicionados no Milestone 1.
- [x] üíæ **COMMIT:** `feat: implement structured logging with pino`
- [x] **0.6 Hello World TDD**
  - Configurar **Vitest** no NestJS.
  - Teste do `AppController` (Health Check).
- [x] üíæ **COMMIT:** `test: configure vitest and add health check test`
- [x] üè∑Ô∏è **TAG:** `git tag -a v0.1.0 -m "Milestone 0: NestJS Foundation"`

---

## üö© Milestone 1: Identidade, Hierarquia e SDK Automation

**Objetivo:** Auth segura e integra√ß√£o Front-Back automatizada.

- [x] **1.1 ÔøΩ Diagrama de Classes (Dom√≠nio Core)**
  - Modelar entidades: `User`, `Team`, `Role`, relacionamentos.
  - Definir atributos e multiplicidades.
  - Criar diagrama UML (PlantUML ou Mermaid).
- [x] üíæ **COMMIT:** `docs: add core domain class diagram`
- [x] **1.2 üìê Modelagem de Dom√≠nio (Prisma)**
  - Schema completo: `Tenant`, `User`, `Lead`, `Contact`, `Deal`, `Activity`
  - Soft Delete: Campo `deletedAt` em Lead, Contact, Deal, Activity
  - Unique Constraints: `[tenantId, email]` em User e Contact
  - Migration Dev: `npx prisma migrate dev --name init-crm-schema`
  - **Aplicar Check Constraint SQL:** Constraint polim√≥rfico em Activity garantindo que `lead_id`, `contact_id` ou `deal_id` seja NOT NULL
- [x] üíæ **COMMIT:** `feat: add crm multi-tenant prisma schema with constraints`
- [x] **1.3 TDD: Auth Service (L√≥gica)**
  - [x] **1.3.1 Instala√ß√£o de Depend√™ncias**
    - Instalar `@nestjs/passport`, `passport`, `@nestjs/jwt`, `passport-jwt`, `argon2` via workspace
    - Instalar `class-validator`, `class-transformer` para valida√ß√£o de DTOs
    - Verificar instala√ß√£o correta no monorepo (sem duplica√ß√£o de node_modules)
  - [x] **1.3.2 Configura√ß√£o de Vari√°veis de Ambiente**
    - Adicionar `JWT_SECRET` (64 caracteres) e `JWT_EXPIRES_IN` no `.env`
    - Criar valida√ß√£o Zod em `env.validation.ts`:
      - `JWT_SECRET`: m√≠nimo 32 caracteres
      - `JWT_EXPIRES_IN`: formato `\d+[smhd]` (ex: 1h, 15m, 7d)
  - [x] **1.3.3 Estrutura do M√≥dulo Auth**
    - Criar pasta `server/src/auth/`
    - Criar `auth.module.ts` (estrutura b√°sica)
    - Criar `auth.service.ts` (classe vazia com `@Injectable`)
    - Criar `auth.controller.ts` (classe vazia com `@Controller('auth')`)
    - Registrar `AuthModule` no `AppModule`
  - [x] **1.3.4 DTOs de Valida√ß√£o**
    - Criar pasta `server/src/auth/dto/`
    - Criar `register.dto.ts`:
      - Validar email (`@IsEmail`)
      - Validar senha (m√≠nimo 8 caracteres, m√°ximo 100)
      - Validar nome (m√≠nimo 2 caracteres, m√°ximo 100)
      - Validar tenantId
    - Criar `login.dto.ts`:
      - Validar email
      - Validar senha (m√≠nimo 1 caractere)
    - Habilitar `ValidationPipe` global no `main.ts` (whitelist, forbidNonWhitelisted, transform)
  - [x] **1.3.5 PrismaService (M√≥dulo Global)**
    - Criar `server/src/prisma/prisma.service.ts`:
      - Estender `PrismaClient`
      - Implementar lifecycle hooks (`OnModuleInit`, `OnModuleDestroy`)
      - Conectar/desconectar automaticamente
    - Criar `server/src/prisma/prisma.module.ts`:
      - Marcar como `@Global()` (dispon√≠vel em todos os m√≥dulos)
      - Exportar `PrismaService`
    - Registrar `PrismaModule` no `AppModule`
    - Corrigir import do Prisma Client para `@prisma/client` (padr√£o)
  - [x] **1.3.6 TDD: Testes do AuthService**
    - Criar `auth.service.spec.ts` (ao lado do servi√ßo, padr√£o NestJS)
    - Configurar imports expl√≠citos do Vitest (`describe`, `it`, `expect`, `vi`)
    - Mockar `PrismaService` com `vi.fn()`
    - Teste RED: "should hash password with argon2 and create user"
    - Teste RED: "should throw ConflictException if email already exists"
  - [x] **1.3.7 Implementa√ß√£o do AuthService.register()**
    - Injetar `PrismaService` via DI
    - Verificar email duplicado (`findUnique` com chave composta `tenantId_email`)
    - Lan√ßar `ConflictException` se usu√°rio j√° existe
    - Hash de senha com `argon2.hash()`
    - Criar usu√°rio no banco com role `MEMBER`
    - Retornar usu√°rio SEM `passwordHash` (usar `select` para excluir)
  - [x] **1.3.8 Testes GREEN**
    - Corrigir mock do Prisma para respeitar `select` (n√£o retornar campos extras)
    - Validar que `passwordHash` n√£o √© exposto na resposta
    - Todos os testes passando (2/2)
- [x] üíæ **COMMIT:** `feat: implement auth service with argon2 and tdd`
- [x] **1.4 Auth Controller & Endpoints HTTP**
  - [x] **1.4.1 Implementar Endpoint de Registro**
    - [x] Criar m√©todo `register()` no `AuthController`
      - Adicionar decorator `@Post('register')`
      - Adicionar decorator `@HttpCode(HttpStatus.CREATED)`
      - Injetar `AuthService` no constructor
      - Receber `RegisterDto` com decorator `@Body()`
      - Chamar `authService.register(registerDto)`
      - Retornar objeto do usu√°rio (sem senha)
    - [x] Adicionar documenta√ß√£o Swagger (prepara√ß√£o)
      - `@ApiTags('auth')`
      - `@ApiOperation({ summary: 'Register new user' })`
      - `@ApiResponse({ status: 201, description: 'User created' })`
      - `@ApiResponse({ status: 409, description: 'Email already exists' })`
- [x] **1.4.2 Testes de Integra√ß√£o do Endpoint de Registro**
  - [x] Configurar setup global de testes
  - [x] Criar `server/src/test/setup.ts`
  - [x] Criar factory `createTestApp()` em `src/test/helpers/test-application.factory.ts`
  - [x] Configurar limpeza autom√°tica do banco (beforeEach com TRUNCATE)
  - [x] Criar `auth.integration.spec.ts` em `src/auth/`
  - [x] Teste: POST /auth/register com dados v√°lidos ‚Üí 201
  - [x] Teste: POST /auth/register com email duplicado ‚Üí 409
  - [x] Teste: POST /auth/register com valida√ß√£o inv√°lida ‚Üí 400
  - [x] Validar que senha N√ÉO aparece na resposta
  - [x] Validar que usu√°rio foi criado no banco (query direta)
- [x] **1.4.3 Implementar Login com JWT**
  - [x] Configurar JwtModule no AuthModule
    - Importar `JwtModule.registerAsync()`
    - Injetar `ConfigService` para ler vari√°veis do `.env`
    - Configurar `secret: configService.get('JWT_SECRET')`
    - Configurar `signOptions: { expiresIn: configService.get('JWT_EXPIRES_IN') }`
  - [x] Criar m√©todo `login()` no AuthService (TDD)
    - [x] Teste RED: "should return access_token for valid credentials"
    - [x] Teste RED: "should throw UnauthorizedException for invalid email"
    - [x] Teste RED: "should throw UnauthorizedException for invalid password"
    - [x] Implementa√ß√£o:
      - Buscar usu√°rio por email e tenantId
      - Lan√ßar `UnauthorizedException` se n√£o encontrar
      - Verificar senha com `argon2.verify(storedHash, plainPassword)`
      - Lan√ßar `UnauthorizedException` se senha inv√°lida
      - Criar payload JWT: `{ sub: user.id, email: user.email, tenantId: user.tenantId, role: user.role }`
      - Assinar token com `jwtService.sign(payload)`
      - Retornar `{ access_token: token }`
    - [x] Testes GREEN: Todos passando
  - [x] Criar endpoint POST `/auth/login` no AuthController
    - Adicionar m√©todo `login()`
    - Receber `LoginDto` com `@Body()`
    - Chamar `authService.login(loginDto)`
    - Retornar `{ access_token }`
  - [x] Teste E2E do Login
    - Criar usu√°rio no banco (seed com senha conhecida)
    - POST `/auth/login` com credenciais corretas ‚Üí 200 + token
    - POST `/auth/login` com email errado ‚Üí 401
    - POST `/auth/login` com senha errada ‚Üí 401
    - Validar que token JWT √© v√°lido (decodificar payload)
- [x] **1.4.4 Criar JwtStrategy (Passport)**
  - [x] Criar pasta `server/src/auth/strategies/`
  - [x] Criar arquivo `jwt.strategy.ts`
    - Importar `PassportStrategy` de `@nestjs/passport`
    - Importar `Strategy, ExtractJwt` de `passport-jwt`
    - Estender `PassportStrategy(Strategy)`
    - Injetar `ConfigService` no constructor
    - Configurar `super()`:
      - `jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken()`
      - `ignoreExpiration: false`
      - `secretOrKey: configService.get('JWT_SECRET')`
    - Implementar `validate(payload)`:
      - Recebe payload decodificado do JWT
      - Retornar objeto do usu√°rio: `{ userId: payload.sub, email: payload.email, tenantId: payload.tenantId, role: payload.role }`
      - Passport injeta retorno em `req.user` automaticamente
  - [x] Criar teste unit√°rio `jwt.strategy.spec.ts`
    - Mockar `ConfigService`
    - Testar m√©todo `validate()`
    - Validar que retorna dados corretos do payload
  - [x] Registrar `JwtStrategy` como provider no `AuthModule`
- [x] **1.4.5 Testar Autentica√ß√£o com Guard**
  - [x] Criar endpoint de teste protegido
    - Adicionar m√©todo `@Get('profile')` no `AuthController`
    - Adicionar `@UseGuards(AuthGuard('jwt'))`
    - Retornar `req.user` (injeta automaticamente)
  - [x] Teste E2E de rota protegida
    - Fazer login ‚Üí obter token
    - GET `/auth/profile` SEM token ‚Üí 401
    - GET `/auth/profile` com token inv√°lido ‚Üí 401
    - GET `/auth/profile` com token v√°lido ‚Üí 200 + dados do usu√°rio
    - GET `/auth/profile` com token expirado ‚Üí 401 (usar mock de tempo)
- [x] üíæ **COMMIT:** `feat: add auth endpoints and jwt strategy`
- [x] **1.5 üõ°Ô∏è Guards RBAC (Controle de Acesso)**
  - [x] **1.5.1 Criar Decorator @Roles()**
    - [x] Criar `server/src/common/decorators/roles.decorator.ts`
      - Usar `SetMetadata` do NestJS
      - Exportar fun√ß√£o `Roles(...roles: Role[])`
      - Armazenar roles na metadata da rota
    - [x] Criar enum de roles (se n√£o existir)
      - `OWNER`, `ADMIN`, `MANAGER`, `MEMBER`
  - [x] **1.5.2 Implementar RolesGuard**
    - [x] Criar `server/src/common/guards/roles.guard.ts`
      - Implementar `CanActivate`
      - Injetar `Reflector` (para ler metadata)
      - M√©todo `canActivate()`:
        - Obter roles necess√°rias da metadata (`@Roles()`)
        - Se n√£o h√° roles definidas, permitir acesso
        - Obter usu√°rio de `request.user` (injetado pelo JwtStrategy)
        - Verificar se `user.role` est√° nas roles permitidas
        - Retornar `true` ou `false`
    - [x] Criar testes unit√°rios `roles.guard.spec.ts`
      - Teste: Permite acesso se usu√°rio tem role correta
      - Teste: Bloqueia acesso se usu√°rio n√£o tem role
      - Teste: Permite acesso se rota n√£o tem `@Roles()`
  - [x] **1.5.3 Implementar Lead Ownership Guard**
    - [x] Criar `server/src/common/guards/lead-ownership.guard.ts`
      - Implementar `CanActivate`
      - Injetar `PrismaService`
      - M√©todo `canActivate()`:
        - Obter usu√°rio de `request.user`
        - Se `role === 'OWNER' || role === 'ADMIN'` ‚Üí permitir (acesso total)
        - Se `role === 'MEMBER'`:
          - Extrair `leadId` dos params da rota
          - Buscar lead no banco (`prisma.lead.findUnique`)
          - Verificar se `lead.ownerId === user.userId`
          - Retornar `true` se for dono, `false` caso contr√°rio
        - Bloquear qualquer outro caso
    - [x] Criar testes TDD `lead-ownership.guard.spec.ts`
      - Mockar `PrismaService`
      - Teste: OWNER acessa qualquer lead
      - Teste: ADMIN acessa qualquer lead
      - Teste: MEMBER acessa apenas seus leads
      - Teste: MEMBER n√£o acessa lead de outro vendedor (403)
  - [x] **1.5.4 Criar Endpoint de Teste para Guards** (Validado via Testes Unit√°rios de Integra√ß√£o do Auth e Guards Unit√°rios)
    - [x] Criar `LeadsController` tempor√°rio (s√≥ para teste)
    - [x] Teste E2E de RBAC
  - [x] **1.5.5 Documentar Guards no Swagger**
    - Adicionar `@ApiBearerAuth()` em rotas protegidas
    - Adicionar `@ApiResponse({ status: 403, description: 'Forbidden' })`
- [x] üíæ **COMMIT:** `feat: add rbac guards with lead ownership validation`
- [x] **1.6 üìö Swagger & SDK Auto-gera√ß√£o**
  - [x] **1.6.1 Configurar Swagger no Backend**
    - [x] Instalar depend√™ncias
      - `npm install @nestjs/swagger --workspace=server`
    - [x] Configurar Swagger no `main.ts`
      - Importar `SwaggerModule, DocumentBuilder`
      - Criar `SwaggerConfig`:
        - T√≠tulo: "Orbit CRM API"
        - Descri√ß√£o: "Enterprise CRM with Multi-tenancy"
        - Vers√£o: "1.0"
        - Tag: "auth", "leads", "contacts", etc.
        - Bearer Auth configurado
      - Criar documento: `SwaggerModule.createDocument(app, config)`
      - Setup: `SwaggerModule.setup('api/docs', app, document)`
    - [x] Adicionar decorators nos DTOs
      - `@ApiProperty()` em todos os campos
      - Exemplos de valores
      - Descri√ß√µes claras
    - [x] Adicionar decorators nos Controllers
      - `@ApiTags('auth')`
      - `@ApiOperation({ summary: '...' })`
      - `@ApiResponse()` para cada status code
      - `@ApiBearerAuth()` em rotas protegidas
    - [x] Testar Swagger UI
      - Iniciar servidor
      - Acessar `http://localhost:3333/api/docs`
      - Validar que todos os endpoints est√£o documentados
      - Testar "Try it out" no Swagger
  - [x] **1.6.2 Configurar SDK Auto-gera√ß√£o no Frontend**
    - [x] Instalar Hey API no workspace web
      - `npm install @hey-api/openapi-ts --save-dev --workspace=web`
    - [x] Criar configura√ß√£o `web/openapi-ts.config.ts`
      - Input: `http://localhost:3333/api/docs-json`
      - Output: `web/src/generated/api`
      - Client: `fetch`
      - Tipos: TypeScript
    - [x] Adicionar script no `web/package.json`
      - `"generate:sdk": "openapi-ts"`
    - [x] Executar gera√ß√£o inicial
      - `npm run generate:sdk --workspace=web`
      - Validar arquivos gerados em `web/src/generated/api/`
    - [x] Criar wrapper do SDK
      - `web/src/lib/api-client.ts`
      - Configurar baseURL
      - Configurar interceptors (adicionar token JWT)
      - Exportar client configurado
    - [x] Adicionar .gitignore
      - Adicionar `web/src/generated/` no `.gitignore`
      - Manter apenas arquivos de configura√ß√£o versionados
  - [x] **1.6.3 Documentar Processo no README**
    - Adicionar se√ß√£o "API Documentation"
    - Instru√ß√µes para acessar Swagger
    - Instru√ß√µes para gerar SDK: `npm run generate:sdk`
    - Exemplos de uso do SDK no frontend
- [x] üíæ **COMMIT:** `chore: setup automated sdk generation from swagger`
- [x] üè∑Ô∏è **TAG:** `git tag -a v0.2.0 -m "Milestone 1: Auth & SDK"`

---

## üö© Milestone 2: Gest√£o de Contatos, Seeding e UX

**Objetivo:** CRUD, Dados Fakes e Interface.

- [ ] **2.1 üìä Atualizar Diagrama de Classes**
  - [ ] **2.1.1 Modelar Entidade Contact**
    - Adicionar classe `Contact` no diagrama UML
    - Atributos: id, tenantId, email, name, phone, company, position, ownerId, createdAt, updatedAt, deletedAt
    - Relacionamentos: `Contact` N:1 `User` (owner)
    - Relacionamentos: `Contact` N:1 `Tenant`
  - [ ] **2.1.2 Modelar Entidade AuditLog**
    - Adicionar classe `AuditLog` no diagrama
    - Atributos: id, userId, action, entity, entityId, changes (JSON), timestamp, ip
    - Relacionamento: `AuditLog` N:1 `User` (quem fez a a√ß√£o)
  - [ ] **2.1.3 Atualizar Relacionamentos**
    - Conectar `Contact` com `User` (ownerId)
    - Conectar `AuditLog` com todas entidades (polim√≥rfico)
    - Validar multiplicidades
- [ ] üíæ **COMMIT:** `docs: update class diagram with contacts module`
- [ ] **2.2 üìê Modelagem de Auditoria (Prisma)**
  - [ ] **2.2.1 Criar Schema AuditLog**
    - [ ] Adicionar model `AuditLog` no `schema.prisma`
      - Campo `id`: String @id @default(cuid())
      - Campo `userId`: String (quem fez a a√ß√£o)
      - Campo `action`: Enum (`CREATE`, `UPDATE`, `DELETE`)
      - Campo `entity`: String (nome da tabela: "Contact", "Lead", etc.)
      - Campo `entityId`: String (ID do registro afetado)
      - Campo `changes`: Json (diff antes/depois)
      - Campo `ip`: String? (IP do cliente)
      - Campo `timestamp`: DateTime @default(now())
      - Rela√ß√£o com `User`: user User @relation(fields: [userId], references: [id])
      - Index em userId, entity, timestamp
  - [ ] **2.2.2 Criar Migration**
    - Executar `npx prisma migrate dev --name add-audit-log`
    - Validar SQL gerado
    - Aplicar migration no banco
  - [ ] **2.2.3 Gerar Prisma Client**
    - Executar `npx prisma generate`
    - Validar tipos TypeScript
- [ ] üíæ **COMMIT:** `feat: add audit log schema`
- [ ] **2.3 üìê Auditoria (AOP com Interceptor)**
  - [ ] **2.3.1 Criar AuditInterceptor**
    - [ ] Criar `server/src/common/interceptors/audit.interceptor.ts`
      - Implementar `NestInterceptor`
      - Injetar `PrismaService`
      - Injetar `Reflector` (para ler metadata)
      - M√©todo `intercept()`:
        - Capturar dados ANTES da execu√ß√£o (estado original)
        - Executar handler (opera√ß√£o real)
        - Capturar dados DEPOIS (estado modificado)
        - Calcular diff (comparar before/after)
        - Criar registro no `AuditLog`
        - Retornar resultado original
    - [ ] Criar decorator `@Audit()` customizado
      - `server/src/common/decorators/audit.decorator.ts`
      - Usar `SetMetadata` para marcar m√©todos audit√°veis
      - Aceitar par√¢metro `entity: string`
  - [ ] **2.3.2 Criar Testes do Interceptor**
    - Mockar `PrismaService`
    - Teste: Cria log ao criar entidade
    - Teste: Cria log ao atualizar entidade
    - Teste: Cria log ao deletar entidade
    - Teste: N√£o cria log se m√©todo n√£o tem `@Audit()`
  - [ ] **2.3.3 Integrar com Controllers**
    - Adicionar `@UseInterceptors(AuditInterceptor)` em ContactsController
    - Adicionar `@Audit('Contact')` nos m√©todos create/update/delete
    - Testar cria√ß√£o de logs automaticamente
- [ ] üíæ **COMMIT:** `feat: implement audit log interceptor`
- [ ] **2.4 Backend: Contacts Module (TDD)**
  - [ ] **2.4.1 Estrutura do M√≥dulo**
    - [ ] Criar pasta `server/src/contacts/`
    - [ ] Criar `contacts.module.ts`
    - [ ] Criar `contacts.service.ts`
    - [ ] Criar `contacts.controller.ts`
    - [ ] Registrar `ContactsModule` no `AppModule`
  - [ ] **2.4.2 DTOs de Valida√ß√£o**
    - [ ] Criar pasta `server/src/contacts/dto/`
    - [ ] Criar `create-contact.dto.ts`:
      - `@IsEmail()` email
      - `@IsString()` name (min 2, max 100)
      - `@IsString() @IsOptional()` phone
      - `@IsString() @IsOptional()` company
      - `@IsString() @IsOptional()` position
    - [ ] Criar `update-contact.dto.ts`:
      - Estender `PartialType(CreateContactDto)`
      - Todos os campos opcionais
    - [ ] Criar `filter-contacts.dto.ts`:
      - Pagina√ß√£o: page, limit
      - Filtros: search (nome/email), company, ownerId
      - Ordena√ß√£o: sortBy, sortOrder
  - [ ] **2.4.3 Implementar ContactsService (TDD)**
    - [ ] Criar `contacts.service.spec.ts`
    - [ ] Teste: `create()` - cria contato com ownerId do usu√°rio autenticado
    - [ ] Teste: `findAll()` - lista apenas contatos do tenant (multi-tenancy)
    - [ ] Teste: `findAll()` - MEMBER v√™ apenas seus contatos
    - [ ] Teste: `findAll()` - OWNER/ADMIN v√™ todos contatos do tenant
    - [ ] Teste: `findOne()` - retorna contato se pertence ao tenant
    - [ ] Teste: `findOne()` - lan√ßa NotFoundException se n√£o encontrar
    - [ ] Teste: `update()` - atualiza apenas se for dono ou admin
    - [ ] Teste: `update()` - lan√ßa ForbiddenException se MEMBER tentar atualizar contato de outro
    - [ ] Teste: `remove()` - soft delete (seta deletedAt)
    - [ ] Teste: `remove()` - lan√ßa ForbiddenException se n√£o for dono
    - [ ] Implementa√ß√£o de todos os m√©todos
  - [ ] **2.4.4 Criar ContactsController**
    - [ ] `@Post()` - Criar contato
      - `@UseGuards(JwtAuthGuard)`
      - `@ApiOperation()`
      - Extrair userId de `req.user`
      - Setar ownerId automaticamente
    - [ ] `@Get()` - Listar contatos (paginado)
      - Aplicar filtros de tenant
      - Aplicar RBAC (member v√™ s√≥ os seus)
      - Retornar com pagina√ß√£o: `{ data, total, page, limit }`
    - [ ] `@Get(':id')` - Buscar um contato
      - Validar ownership
    - [ ] `@Patch(':id')` - Atualizar contato
      - Validar ownership
      - `@Audit('Contact')`
    - [ ] `@Delete(':id')` - Deletar contato (soft delete)
      - Validar ownership
      - `@Audit('Contact')`
  - [ ] **2.4.5 Testes E2E de Contacts**
    - POST `/contacts` ‚Üí 201 (cria com ownerId correto)
    - GET `/contacts` como MEMBER ‚Üí lista apenas seus contatos
    - GET `/contacts` como OWNER ‚Üí lista todos do tenant
    - GET `/contacts/:id` de outro vendedor ‚Üí 403
    - PATCH `/contacts/:id` de outro vendedor ‚Üí 403
    - DELETE `/contacts/:id` ‚Üí soft delete (deletedAt n√£o √© null)
  - [ ] **2.4.6 Database Seeding**
    - [ ] Instalar Faker.js
      - `npm install @faker-js/faker --save-dev --workspace=server`
    - [ ] Criar `server/prisma/seed.ts`
      - Importar `PrismaClient` e `faker`
      - Criar fun√ß√£o `main()`:
        - Limpar dados existentes (opcional em dev)
        - Criar 2 tenants
        - Criar 5 usu√°rios por tenant (1 owner, 1 admin, 3 members)
        - Criar 50 contatos por tenant (distribuir entre vendedores)
        - Criar 20 leads por tenant
        - Criar 10 deals por tenant
        - Criar 30 atividades (distribu√≠das entre leads/contacts/deals)
      - Executar seed
    - [ ] Configurar script no `server/package.json`
      - `"seed": "tsx prisma/seed.ts"`
    - [ ] Testar seed: `npm run seed --workspace=server`
- [ ] üíæ **COMMIT:** `feat: contacts crud and database seeder`
- [ ] **2.5 Frontend: Setup & Navigation**
  - [ ] **2.5.1 Instalar Depend√™ncias UI**
    - [ ] Shadcn/UI
      - `npx shadcn@latest init --workspace=web`
      - Configurar Tailwind v4
      - Escolher tema e cores
    - [ ] Instalar componentes base
      - `npx shadcn@latest add button card input label --workspace=web`
      - `npx shadcn@latest add dialog dropdown-menu table --workspace=web`
      - `npx shadcn@latest add command --workspace=web` (Command Palette)
    - [ ] Configurar React Router
      - `npm install react-router-dom --workspace=web`
      - Criar estrutura de rotas
  - [ ] **2.5.2 Estrutura de Pastas Frontend**
    - [ ] Criar `web/src/components/` (componentes reutiliz√°veis)
    - [ ] Criar `web/src/pages/` (p√°ginas/rotas)
    - [ ] Criar `web/src/layouts/` (layouts com sidebar/header)
    - [ ] Criar `web/src/hooks/` (custom hooks)
    - [ ] Criar `web/src/lib/` (utilit√°rios)
    - [ ] Criar `web/src/stores/` (Zustand para estado global)
  - [ ] **2.5.3 Implementar Command Palette (Cmdk)**
    - [ ] Criar `web/src/components/command-palette.tsx`
      - Usar componente `<Command>` do Shadcn
      - Atalho: Ctrl+K (Windows) / Cmd+K (Mac)
      - Se√ß√µes: Navega√ß√£o, A√ß√µes, Contatos recentes
      - Navega√ß√£o r√°pida para: Dashboard, Contatos, Pipeline, Configura√ß√µes
    - [ ] Integrar no layout principal
      - Adicionar listener global de teclado
      - Renderizar dialog com Command
  - [ ] **2.5.4 Criar Layout Principal**
    - [ ] Criar `web/src/layouts/dashboard-layout.tsx`
      - Sidebar com navega√ß√£o
      - Header com breadcrumbs e user menu
      - Outlet para renderizar p√°ginas
      - Command Palette integrado
    - [ ] Criar componentes de navega√ß√£o
      - `<Sidebar>` com links: Dashboard, Contatos, Pipeline, Equipe
      - `<UserMenu>` com dropdown: Perfil, Configura√ß√µes, Logout
  - [ ] **2.5.5 Integrar SDK Gerado**
    - [ ] Criar `web/src/lib/api-client.ts`
      - Importar SDK gerado (`@hey-api/openapi-ts`)
      - Configurar baseURL: `http://localhost:3333`
      - Criar interceptor para adicionar JWT:
        - Ler token do localStorage
        - Adicionar header `Authorization: Bearer ${token}`
      - Criar interceptor para refresh token (futuro)
      - Exportar client configurado
    - [ ] Criar custom hooks para API
      - `web/src/hooks/use-auth.ts` (login, register, logout)
      - `web/src/hooks/use-contacts.ts` (CRUD de contatos)
    - [ ] Configurar React Query
      - `npm install @tanstack/react-query --workspace=web`
      - Criar `QueryClientProvider` no root
      - Configurar cache e retry
  - [ ] **2.5.6 P√°gina de Login**
    - Criar `web/src/pages/login.tsx`
    - Form com email e senha
    - Valida√ß√£o com React Hook Form + Zod
    - Chamar API via SDK
    - Armazenar token no localStorage
    - Redirecionar para dashboard
  - [ ] **2.5.7 Prote√ß√£o de Rotas**
    - Criar `<ProtectedRoute>` component
    - Verificar se token existe
    - Redirecionar para login se n√£o autenticado
    - Aplicar em todas as rotas internas
- [ ] üíæ **COMMIT:** `feat(web): setup ui and command palette navigation`
- [ ] **2.6 Frontend: Data Grid de Contatos**
  - [ ] **2.6.1 Instalar TanStack Table**
    - `npm install @tanstack/react-table --workspace=web`
    - Instalar componentes Shadcn: `npx shadcn@latest add table`
  - [ ] **2.6.2 Criar P√°gina de Contatos**
    - [ ] Criar `web/src/pages/contacts/contacts-list.tsx`
      - Usar `useContacts()` hook para buscar dados
      - Implementar pagina√ß√£o server-side
      - Implementar busca/filtros
      - Implementar ordena√ß√£o por coluna
    - [ ] Criar componente `<ContactsTable>`
      - Configurar colunas: Nome, Email, Empresa, Telefone, Dono, Data cria√ß√£o
      - A√ß√µes: Editar, Deletar
      - Row selection (checkbox)
      - Bulk actions: Deletar selecionados
    - [ ] Criar componente `<ContactsFilters>`
      - Input de busca (nome/email)
      - Select de empresa
      - Select de vendedor (apenas para admin/owner)
    - [ ] Criar bot√£o "Novo Contato"
      - Abre dialog com formul√°rio
      - Submit via API
      - Revalida lista ap√≥s criar
  - [ ] **2.6.3 Criar Formul√°rio de Contato**
    - [ ] Criar `web/src/components/contact-form.tsx`
      - Campos: Nome, Email, Telefone, Empresa, Cargo
      - Valida√ß√£o com Zod
      - Submit com React Hook Form
      - Loading state
      - Error handling
    - [ ] Integrar em Dialog
      - Reutilizar para Create e Edit
      - Preencher valores no modo Edit
  - [ ] **2.6.4 Implementar A√ß√µes na Tabela**
    - [ ] Editar contato
      - Abrir dialog preenchido
      - PATCH via API
      - Revalidar lista
    - [ ] Deletar contato
      - Confirma√ß√£o com AlertDialog
      - DELETE via API
      - Remover da lista (optimistic update)
    - [ ] Bulk delete
      - Confirmar m√∫ltipla sele√ß√£o
      - Deletar em batch
  - [ ] **2.6.5 Implementar Pagina√ß√£o**
    - Criar componente `<Pagination>`
    - Controles: Previous, Next, Page numbers
    - Mostrar total de registros
    - Sincronizar com query params da URL
  - [ ] **2.6.6 Testes E2E Frontend (Playwright)**
    - [ ] Configurar Playwright
      - `npm create playwright@latest --workspace=web`
      - Configurar browsers: chromium, firefox
    - [ ] Criar `web/tests/contacts.spec.ts`
      - Teste: Listar contatos
      - Teste: Criar novo contato
      - Teste: Editar contato existente
      - Teste: Deletar contato
      - Teste: Filtrar por busca
      - Teste: Pagina√ß√£o funciona
- [ ] üíæ **COMMIT:** `feat(web): contacts data grid`
- [ ] üè∑Ô∏è **TAG:** `git tag -a v0.3.0 -m "Milestone 2: Contacts & UX"`

---

## üö© Milestone 3: Pipeline Real-Time & Storage

**Objetivo:** Colabora√ß√£o s√≠ncrona e Uploads.

- [ ] **3.1 üìä Atualizar Diagrama de Classes**
  - [ ] **3.1.1 Modelar Entidade Deal**
    - Adicionar classe `Deal` no diagrama
    - Atributos: id, tenantId, contactId, title, value, stage, probability, expectedCloseDate, ownerId, createdAt, updatedAt, deletedAt
    - Relacionamentos: `Deal` N:1 `Contact`, `Deal` N:1 `User` (owner)
  - [ ] **3.1.2 Modelar Entidade PipelineStage**
    - Atributos: id, tenantId, name, order, probability
    - Enum stages: LEAD, QUALIFICATION, PROPOSAL, NEGOTIATION, CLOSED_WON, CLOSED_LOST
  - [ ] **3.1.3 Modelar Entidade Attachment**
    - Atributos: id, entityType, entityId, fileName, fileSize, mimeType, s3Key, uploadedBy, uploadedAt
    - Relacionamento polim√≥rfico (Deal, Contact, Lead)
- [ ] üíæ **COMMIT:** `docs: update class diagram with pipeline module`
- [ ] **3.2 ‚òÅÔ∏è Storage Module (S3/MinIO)**
  - [ ] **3.2.1 Configurar MinIO no Docker Compose**
    - Adicionar servi√ßo MinIO no `docker-compose.yml`
    - Configurar buckets padr√£o
    - Vari√°veis: `MINIO_ROOT_USER`, `MINIO_ROOT_PASSWORD`
  - [ ] **3.2.2 Instalar AWS SDK**
    - `npm install @aws-sdk/client-s3 @aws-sdk/s3-request-presigner --workspace=server`
  - [ ] **3.2.3 Criar StorageModule**
    - [ ] Criar `server/src/storage/storage.module.ts`
    - [ ] Criar `server/src/storage/storage.service.ts`:
      - Configurar S3Client do AWS SDK
      - M√©todo `generatePresignedUploadUrl(fileName, mimeType, maxSize)`:
        - Validar MIME type (whitelist: images, PDFs, docs)
        - Validar tamanho m√°ximo (ex: 10MB)
        - Gerar chave S3 √∫nica: `tenant-id/deals/uuid-filename`
        - Gerar URL assinada (v√°lida por 15 minutos)
        - Retornar: `{ uploadUrl, key, expiresIn }`
      - M√©todo `generatePresignedDownloadUrl(key, expiresIn)`:
        - Validar que arquivo existe
        - Gerar URL de download assinada
        - Retornar URL v√°lida por tempo limitado
      - M√©todo `deleteFile(key)`:
        - Remover arquivo do S3
  - [ ] **3.2.4 Criar Testes TDD**
    - Mockar S3Client
    - Teste: Gera URL de upload v√°lida
    - Teste: Rejeita MIME type inv√°lido
    - Teste: Rejeita arquivo muito grande
    - Teste: Gera URL de download
  - [ ] **3.2.5 Criar StorageController**
    - `POST /storage/upload-url` ‚Üí Retorna presigned URL
    - `GET /storage/download-url/:key` ‚Üí Retorna download URL
    - Aplicar `@UseGuards(JwtAuthGuard)`
  - [ ] **3.2.6 Criar Schema Attachment no Prisma**
    - Adicionar model `Attachment`
    - Migration
- [ ] üíæ **COMMIT:** `feat: secure storage module`
- [ ] **3.3 Backend: WebSockets (Real-time)**
  - [ ] **3.3.1 Instalar Socket.io**
    - `npm install @nestjs/websockets @nestjs/platform-socket.io socket.io --workspace=server`
  - [ ] **3.3.2 Criar EventsGateway**
    - [ ] Criar `server/src/events/events.gateway.ts`
      - `@WebSocketGateway()` com CORS configurado
      - Implementar `OnGatewayConnection`, `OnGatewayDisconnect`
      - Autenticar conex√£o via JWT:
        - Extrair token de `socket.handshake.auth.token`
        - Validar JWT
        - Armazenar `userId` e `tenantId` em `socket.data`
      - Criar sala por tenant: `socket.join(tenantId)`
    - [ ] Evento `deal.moved`:
      - Listener: `@SubscribeMessage('deal.moved')`
      - Payload: `{ dealId, fromStage, toStage, userId }`
      - Validar que usu√°rio pode mover o deal
      - Atualizar deal no banco
      - Emitir para todos no tenant: `server.to(tenantId).emit('deal.updated', payload)`
    - [ ] Evento `deal.created`:
      - Broadcast cria√ß√£o de novo deal
    - [ ] Evento `deal.deleted`:
      - Broadcast remo√ß√£o de deal
  - [ ] **3.3.3 Criar Testes E2E de WebSocket**
    - Configurar cliente Socket.io no teste
    - Teste: Conex√£o com JWT v√°lido
    - Teste: Rejeita conex√£o sem JWT
    - Teste: Recebe evento ao mover deal
    - Teste: Isolamento por tenant (tenant A n√£o v√™ eventos do B)
- [ ] üíæ **COMMIT:** `feat: websocket gateway`
- [ ] **3.4 Frontend: Kanban Board**
  - [ ] **3.4.1 Instalar Depend√™ncias**
    - `npm install @dnd-kit/core @dnd-kit/sortable socket.io-client --workspace=web`
    - `npx shadcn@latest add card badge --workspace=web`
  - [ ] **3.4.2 Criar P√°gina Pipeline**
    - [ ] Criar `web/src/pages/pipeline/pipeline.tsx`
      - Layout de colunas (stages): LEAD, QUALIFICATION, PROPOSAL, etc.
      - Listar deals em cada coluna
      - Exibir: T√≠tulo, Valor, Contato, Probabilidade
  - [ ] **3.4.3 Implementar Drag & Drop**
    - [ ] Configurar `DndContext` do @dnd-kit
      - Callback `onDragEnd()`:
        - Otimistic update (mover card visualmente)
        - Emitir evento WebSocket `deal.moved`
        - Rollback se falhar
      - Sortable por coluna
    - [ ] Criar componente `<DealCard>`
      - Draggable com `useSortable()`
      - Exibir informa√ß√µes do deal
      - Bot√£o de editar (abre dialog)
  - [ ] **3.4.4 Integrar WebSocket no Frontend**
    - [ ] Criar `web/src/hooks/use-socket.ts`
      - Conectar ao servidor Socket.io
      - Enviar JWT no handshake
      - Listeners:
        - `deal.updated` ‚Üí Atualizar lista local
        - `deal.created` ‚Üí Adicionar √† lista
        - `deal.deleted` ‚Üí Remover da lista
      - Reconnection autom√°tica
    - [ ] Usar hook na p√°gina Pipeline
      - Sincroniza√ß√£o real-time entre usu√°rios
  - [ ] **3.4.5 Implementar Upload de Anexos**
    - [ ] Criar componente `<FileUpload>`
      - Input de arquivo (drag & drop ou clique)
      - Validar MIME e tamanho no frontend
      - Preview de imagens
    - [ ] Fluxo de upload:
      1. Usu√°rio seleciona arquivo
      2. Frontend chama `POST /storage/upload-url`
      3. Backend retorna presigned URL
      4. Frontend faz PUT direto para S3/MinIO (sem passar pelo backend)
      5. Frontend chama `POST /attachments` com S3 key
      6. Backend salva registro no banco
    - [ ] Exibir lista de anexos
      - Download via presigned URL
      - Deletar anexo
  - [ ] **3.4.6 Testes E2E Frontend**
    - Teste: Arrastar deal de uma coluna para outra
    - Teste: Outro usu√°rio v√™ atualiza√ß√£o em tempo real
    - Teste: Upload de anexo
    - Teste: Download de anexo
- [ ] üíæ **COMMIT:** `feat(web): kanban board with sync and uploads`
- [ ] üè∑Ô∏è **TAG:** `git tag -a v0.4.0 -m "Milestone 3: Pipeline & Storage"`

---

## üö© Milestone 4: Processamento Ass√≠ncrono (Workers)

**Objetivo:** Filas para tarefas pesadas.

- [ ] **4.1 üìê BullMQ Setup**
  - [ ] **4.1.1 Instalar Depend√™ncias**
    - `npm install @nestjs/bullmq bullmq --workspace=server`
    - Redis j√° est√° no Docker Compose (Milestone 0)
  - [ ] **4.1.2 Configurar BullModule**
    - [ ] Criar `server/src/queues/queues.module.ts`
    - [ ] Importar `BullModule.forRoot()`:
      - Configurar conex√£o Redis do `.env`
      - `REDIS_HOST`, `REDIS_PORT`, `REDIS_PASSWORD`
    - [ ] Registrar fila `mail-queue`:
      - `BullModule.registerQueue({ name: 'mail-queue' })`
  - [ ] **4.1.3 Adicionar Vari√°veis de Ambiente**
    - Adicionar no `server/.env`: `REDIS_HOST=localhost`, `REDIS_PORT=6379`
    - Validar com Zod em `env.validation.ts`
- [ ] üíæ **COMMIT:** `chore: setup bullmq`
- [ ] **4.2 Workers & Invites**
  - [ ] **4.2.1 Criar Schema de Convite**
    - [ ] Adicionar model `TeamInvite` no Prisma:
      - id, tenantId, email, role, invitedBy, token, expiresAt, acceptedAt
      - Status: PENDING, ACCEPTED, EXPIRED
    - [ ] Migration
  - [ ] **4.2.2 Criar MailProcessor (Worker)**
    - [ ] Criar `server/src/queues/processors/mail.processor.ts`
      - `@Processor('mail-queue')`
      - M√©todo `@Process('send-invite')`:
        - Recebe payload: `{ email, inviteLink, inviterName }`
        - Montar template HTML de email
        - Enviar email via SMTP (Nodemailer) ou servi√ßo (SendGrid, Resend)
        - Logar sucesso/falha
      - Retry autom√°tico (3 tentativas com backoff exponencial)
  - [ ] **4.2.3 Configurar Nodemailer**
    - `npm install nodemailer @types/nodemailer --workspace=server`
    - Configurar transporter SMTP
    - Vari√°veis `.env`: `SMTP_HOST`, `SMTP_PORT`, `SMTP_USER`, `SMTP_PASS`
  - [ ] **4.2.4 Criar InviteMemberService (Producer)**
    - [ ] Criar `server/src/team/team.service.ts`
      - Injetar `@InjectQueue('mail-queue')`
      - M√©todo `inviteMember(email, role, invitedBy)`:
        - Gerar token √∫nico (JWT ou UUID)
        - Criar registro `TeamInvite` no banco
        - Adicionar job na fila:
          ```ts
          await mailQueue.add('send-invite', {
            email,
            inviteLink: `https://app.com/accept-invite/${token}`,
            inviterName: invitedBy.name,
          });
          ```
        - Retornar sucesso
  - [ ] **4.2.5 Criar TeamController**
    - `POST /team/invite` ‚Üí Adiciona convite na fila
    - `POST /team/accept/:token` ‚Üí Aceita convite (cria usu√°rio)
    - `GET /team/invites` ‚Üí Lista convites pendentes
  - [ ] **4.2.6 Testes TDD**
    - Mockar BullMQ Queue
    - Teste: Criar convite adiciona job na fila
    - Teste: Worker envia email (mockar Nodemailer)
    - Teste: Retry em caso de falha
  - [ ] **4.2.7 Dashboard BullMQ (Opcional)**
    - Instalar `@bull-board/nestjs`
    - Configurar em `/admin/queues`
    - Visualizar jobs: pending, completed, failed
- [ ] üíæ **COMMIT:** `feat: mail processor and invite logic`
- [ ] **4.3 Frontend: Team UI**
  - [ ] **4.3.1 Criar P√°gina de Equipe**
    - [ ] Criar `web/src/pages/team/team.tsx`
      - Listar membros do time (com roles)
      - Listar convites pendentes
      - Bot√£o "Convidar Membro"
  - [ ] **4.3.2 Modal de Convite**
    - [ ] Criar componente `<InviteMemberDialog>`
      - Form: Email, Role (select)
      - Submit: POST `/team/invite`
      - Loading state
      - Sucesso: Fechar modal + toast
  - [ ] **4.3.3 P√°gina de Aceitar Convite**
    - [ ] Criar `web/src/pages/accept-invite/:token.tsx`
      - Exibir informa√ß√µes do convite
      - Form: Criar senha
      - Submit: POST `/team/accept/:token`
      - Redirecionar para dashboard
  - [ ] **4.3.4 Testes E2E**
    - Teste: Convidar membro
    - Teste: Email recebido (mock)
    - Teste: Aceitar convite
- [ ] üíæ **COMMIT:** `feat(web): team management ui`
- [ ] üè∑Ô∏è **TAG:** `git tag -a v0.4.5 -m "Milestone 4: Async Teams"`

---

## üö© Milestone 5: Analytics & Testes E2E

**Objetivo:** Qualidade final e Dashboards.

- [ ] **5.1 Backend: Dashboard (Agrega√ß√µes)**
  - [ ] **5.1.1 Criar DashboardService**
    - [ ] Criar `server/src/dashboard/dashboard.service.ts`
      - M√©todo `getMetrics(userId, tenantId, dateRange)`:
        - Total de contatos (filtrado por tenant)
        - Total de deals
        - Taxa de convers√£o (deals won / total deals)
        - Valor total em pipeline
        - Deals por stage (count)
      - M√©todo `getDealsOverTime(tenantId, dateRange)`:
        - Agrupar deals por data de cria√ß√£o
        - Retornar s√©rie temporal: `{ date, count, totalValue }`
      - M√©todo `getTopPerformers(tenantId, dateRange)`:
        - Agrupar deals por ownerId
        - Somar valores won
        - Ordenar por valor total
        - Retornar top 10
      - M√©todo `getConversionFunnel(tenantId)`:
        - Contar deals em cada stage
        - Calcular % de convers√£o entre stages
  - [ ] **5.1.2 Usar Agrega√ß√µes do Prisma**
    - Exemplo: `prisma.deal.groupBy({ by: ['stage'], _count: true, _sum: { value: true } })`
    - Otimizar queries (evitar N+1)
    - Adicionar indexes no Prisma
  - [ ] **5.1.3 Criar DashboardController**
    - `GET /dashboard/metrics` ‚Üí Retorna KPIs
    - `GET /dashboard/deals-over-time` ‚Üí S√©rie temporal
    - `GET /dashboard/top-performers` ‚Üí Ranking
    - `GET /dashboard/funnel` ‚Üí Funil de convers√£o
    - Aplicar `@UseGuards(JwtAuthGuard)`
    - Cache com Redis (15 minutos)
  - [ ] **5.1.4 Testes TDD**
    - Mockar Prisma
    - Teste: Calcula m√©tricas corretamente
    - Teste: Filtra por tenant
    - Teste: Respeita RBAC (member v√™ apenas seus dados)
- [ ] üíæ **COMMIT:** `feat: dashboard aggregations`
- [ ] **5.2 Frontend: Charts (Visualiza√ß√µes)**
  - [ ] **5.2.1 Instalar Recharts**
    - `npm install recharts --workspace=web`
  - [ ] **5.2.2 Criar P√°gina Dashboard**
    - [ ] Criar `web/src/pages/dashboard/dashboard.tsx`
      - Grid responsivo (4 colunas)
      - Cards de KPIs: Total Contatos, Deals, Taxa Convers√£o, Valor Pipeline
      - Gr√°fico de linha: Deals ao longo do tempo
      - Gr√°fico de barras: Deals por stage
      - Tabela: Top performers
  - [ ] **5.2.3 Criar Componentes de Charts**
    - [ ] `<MetricCard>`: Card com t√≠tulo, valor, varia√ß√£o (+/- %)
    - [ ] `<LineChart>`: Recharts LineChart configurado
    - [ ] `<BarChart>`: Recharts BarChart configurado
    - [ ] `<FunnelChart>`: Visualiza√ß√£o de funil customizada
  - [ ] **5.2.4 Integrar API**
    - Criar hook `use-dashboard.ts`
    - Fetch de dados via SDK
    - Loading skeletons
    - Error handling
  - [ ] **5.2.5 Filtros de Data**
    - Componente `<DateRangePicker>`
    - Op√ß√µes: Hoje, 7 dias, 30 dias, 90 dias, Custom
    - Refetch ao mudar filtro
- [ ] üíæ **COMMIT:** `feat(web): analytics dashboard`
- [ ] **5.3 üß™ Testes E2E Completos (Playwright)**
  - [ ] **5.3.1 Configurar Playwright no Backend**
    - Criar `server/test/e2e/setup.ts`
    - Configurar banco de testes (separado)
    - Seed de dados de teste
  - [ ] **5.3.2 Criar Testes de Autentica√ß√£o**
    - [ ] `server/test/e2e/auth.e2e.spec.ts`
      - Teste: Registro de usu√°rio
      - Teste: Login com credenciais corretas
      - Teste: Login com credenciais erradas ‚Üí 401
      - Teste: Acesso a rota protegida sem token ‚Üí 401
      - Teste: Acesso a rota protegida com token ‚Üí 200
  - [ ] **5.3.3 Criar Testes de Fluxo Completo**
    - [ ] `server/test/e2e/crm.e2e.spec.ts`
      - Cen√°rio: Criar lead ‚Üí Qualificar ‚Üí Criar contact ‚Üí Criar deal ‚Üí Mover pipeline ‚Üí Fechar neg√≥cio
      - Validar cada etapa
      - Validar audit logs criados
  - [ ] **5.3.4 Criar Testes de RBAC**
    - [ ] `server/test/e2e/rbac.e2e.spec.ts`
      - Teste: Member n√£o acessa lead de outro ‚Üí 403
      - Teste: Admin acessa todos leads ‚Üí 200
      - Teste: Owner pode deletar qualquer recurso
  - [ ] **5.3.5 Configurar Playwright no Frontend**
    - Testes j√° iniciados no Milestone 2
    - Expandir cobertura
  - [ ] **5.3.6 Criar Testes de Jornada do Usu√°rio**
    - [ ] `web/tests/user-journey.spec.ts`
      - Login ‚Üí Dashboard ‚Üí Ver m√©tricas
      - Criar contato ‚Üí Criar deal ‚Üí Mover kanban
      - Upload de anexo
      - Convidar membro
  - [ ] **5.3.7 Configurar CI para E2E**
    - Rodar testes em headless mode
    - Gerar relat√≥rios HTML
    - Armazenar screenshots de falhas
- [ ] üíæ **COMMIT:** `test: playwright e2e scenarios`
- [ ] üè∑Ô∏è **TAG:** `git tag -a v0.5.0 -m "Milestone 5: Dashboard & QA"`

---

## üö© Milestone 6: Security Hardening (Blindagem)

**Objetivo:** Auditoria e Prote√ß√£o.

- [ ] **6.1 üõ°Ô∏è Security Gates**
  - [ ] **6.1.1 Implementar Rate Limiting**
    - [ ] Instalar ThrottlerModule
      - `npm install @nestjs/throttler --workspace=server`
    - [ ] Configurar globalmente:
      - Limite: 100 requests / 1 minuto (padr√£o)
      - Login: 5 tentativas / 15 minutos
      - API endpoints: 300 requests / 1 minuto
    - [ ] Aplicar throttler customizado no `AuthController`:
      - `@Throttle({ default: { limit: 5, ttl: 900000 } })` no login
    - [ ] Storage: Redis para controle distribu√≠do
  - [ ] **6.1.2 Configurar CORS Restrito**
    - [ ] Whitelist de origens permitidas
      - Ambiente dev: `http://localhost:5173`
      - Ambiente prod: `https://app.orbitcrm.com`
    - [ ] Configurar no `main.ts`:
      - `credentials: true`
      - `methods: ['GET', 'POST', 'PATCH', 'DELETE']`
      - `allowedHeaders: ['Content-Type', 'Authorization']`
  - [ ] **6.1.3 Implementar Content Security Policy**
    - Atualizar configura√ß√£o do Helmet
    - Adicionar diretivas espec√≠ficas
    - Bloquear inline scripts (XSS)
  - [ ] **6.1.4 Adicionar Request ID e Logging**
    - Middleware para gerar UUID por request
    - Incluir em todos os logs
    - Retornar no header `X-Request-ID`
- [ ] **6.2 üõ°Ô∏è Pentest Simulado (TDD)**
  - [ ] **6.2.1 Teste: Escala√ß√£o de Privil√©gio**
    - [ ] `server/test/security/privilege-escalation.spec.ts`
      - Criar usu√°rio MEMBER
      - Tentar acessar rota admin: `GET /admin/users` ‚Üí 403
      - Tentar modificar pr√≥prio role via PATCH ‚Üí 403
      - Validar que n√£o consegue executar a√ß√µes de admin
  - [ ] **6.2.2 Teste: SQL Injection**
    - Tentar injetar SQL em par√¢metros de busca
    - Exemplo: `GET /contacts?search='; DROP TABLE users--`
    - Validar que Prisma sanitiza automaticamente
  - [ ] **6.2.3 Teste: Upload de Arquivo Malicioso**
    - [ ] `server/test/security/file-upload.spec.ts`
      - Tentar upload de arquivo .exe ‚Üí 400
      - Tentar upload de arquivo com MIME type falso ‚Üí 400
      - Tentar upload de arquivo > tamanho m√°ximo ‚Üí 413
      - Tentar upload de script PHP disfar√ßado de imagem ‚Üí 400
  - [ ] **6.2.4 Teste: JWT Token Manipulation**
    - Criar token com payload modificado (role alterado)
    - Tentar acessar API ‚Üí 401
    - Tentar usar token expirado ‚Üí 401
    - Tentar usar token de outro tenant ‚Üí 403
  - [ ] **6.2.5 Teste: Bypass de Multi-tenancy**
    - Criar 2 tenants
    - Usu√°rio do tenant A tenta acessar contato do tenant B ‚Üí 404 (n√£o 403 para n√£o vazar exist√™ncia)
    - Validar isolamento total
  - [ ] **6.2.6 Teste: CORS Bypass**
    - Tentar request de origem n√£o permitida ‚Üí CORS error
    - Validar headers CORS apenas para origens whitelisted
  - [ ] **6.2.7 Teste: Rate Limiting Bypass**
    - Enviar 100 requests em 10 segundos
    - Validar que > 100 retorna 429 (Too Many Requests)
- [ ] **6.3 üõ°Ô∏è Supply Chain Security**
  - [ ] **6.3.1 Audit de Depend√™ncias**
    - Executar `npm audit` na raiz e em cada workspace
    - Corrigir vulnerabilidades HIGH e CRITICAL
    - Documentar vulnerabilidades LOW aceit√°veis
  - [ ] **6.3.2 Atualizar Depend√™ncias**
    - `npm outdated` para listar pacotes desatualizados
    - Atualizar patch versions automaticamente
    - Testar antes de atualizar minor/major
  - [ ] **6.3.3 Configurar Dependabot (GitHub)**
    - Criar `.github/dependabot.yml`
    - Configurar alerts autom√°ticos
    - PRs autom√°ticos para security updates
  - [ ] **6.3.4 Adicionar License Checker**
    - `npm install --save-dev license-checker`
    - Script para validar licen√ßas permitidas
    - Bloquear licen√ßas GPL em produ√ß√£o (se aplic√°vel)
  - [ ] **6.3.5 Configurar .npmrc**
    - Habilitar `package-lock=true`
    - Desabilitar `save-exact=false`
    - Configurar registry seguro
- [ ] üíæ **COMMIT:** `chore: apply security hardening`
- [ ] üè∑Ô∏è **TAG:** `git tag -a v0.6.0 -m "Milestone 6: Security Hardening"`

---

## üö© Milestone 7: Orquestra√ß√£o Kubernetes Multi-Ambiente

**Objetivo:** Deploy profissional com separa√ß√£o de cargas.

- [ ] **7.1 Arquitetura de Processos (NestJS Standalone)**
  - [ ] **7.1.1 Criar Worker Standalone**
    - [ ] Criar `server/src/worker.ts`
      - Importar apenas `QueuesModule` e `PrismaModule`
      - N√ÉO inicializar servidor HTTP (sem Fastify)
      - Apenas processar jobs do BullMQ
      - Graceful shutdown em SIGTERM
    - [ ] Adicionar script no `package.json`:
      - `"start:worker": "node dist/worker.js"`
  - [ ] **7.1.2 Separar Concerns**
    - API: Processa requests HTTP (stateless)
    - Worker: Processa filas (pode ser scaled independentemente)
    - Benef√≠cio: Escalar API e Workers de forma diferente
- [ ] **7.2 Manifestos Kubernetes**
  - [ ] **7.2.1 Criar Namespace**
    - [ ] Criar `k8s/namespace.yaml`
      - Namespace: `orbit-crm-prod`
      - Namespace: `orbit-crm-staging`
  - [ ] **7.2.2 ConfigMap e Secrets**
    - [ ] Criar `k8s/configmap.yaml`
      - Vari√°veis n√£o-sens√≠veis: `NODE_ENV`, `PORT`, `DATABASE_URL` (sem senha)
    - [ ] Criar `k8s/secrets.yaml` (n√£o versionar!)
      - Vari√°veis sens√≠veis: `JWT_SECRET`, `DATABASE_PASSWORD`, `SMTP_PASSWORD`
      - Usar `kubectl create secret` em vez de YAML
  - [ ] **7.2.3 Deployment API**
    - [ ] Criar `k8s/deployment-api.yaml`
      - Replicas: 3 (alta disponibilidade)
      - Container: `orbit-crm-api:latest`
      - Command: `npm run start:prod`
      - Resources:
        - Requests: CPU 200m, Memory 256Mi
        - Limits: CPU 500m, Memory 512Mi
      - Probes:
        - Liveness: `GET /health` every 30s
        - Readiness: `GET /health/ready` every 10s
      - EnvFrom: ConfigMap + Secrets
  - [ ] **7.2.4 Deployment Worker**
    - [ ] Criar `k8s/deployment-worker.yaml`
      - Replicas: 2 (processar filas)
      - Container: `orbit-crm-api:latest`
      - Command: `npm run start:worker`
      - Resources:
        - Requests: CPU 100m, Memory 128Mi
        - Limits: CPU 300m, Memory 256Mi
      - EnvFrom: ConfigMap + Secrets
  - [ ] **7.2.5 StatefulSet PostgreSQL**
    - [ ] Criar `k8s/statefulset-postgres.yaml`
      - Replicas: 1 (ou 3 para HA com replica√ß√£o)
      - PersistentVolumeClaim: 10Gi
      - Image: `postgres:17.2-alpine`
  - [ ] **7.2.6 StatefulSet Redis**
    - [ ] Criar `k8s/statefulset-redis.yaml`
      - Replicas: 1 (ou Redis Cluster)
      - Image: `redis:7-alpine`
  - [ ] **7.2.7 StatefulSet MinIO**
    - [ ] Criar `k8s/statefulset-minio.yaml`
      - Replicas: 1
      - PersistentVolumeClaim: 50Gi
      - Image: `minio/minio:latest`
  - [ ] **7.2.8 Services**
    - [ ] Criar `k8s/service-api.yaml`
      - Type: ClusterIP
      - Port: 3333
      - Selector: `app=orbit-crm-api`
    - [ ] Criar `k8s/service-postgres.yaml`
      - Type: ClusterIP
      - Port: 5432
    - [ ] Criar `k8s/service-redis.yaml`
      - Type: ClusterIP
      - Port: 6379
    - [ ] Criar `k8s/service-minio.yaml`
      - Type: ClusterIP
      - Port: 9000 (API), 9001 (Console)
  - [ ] **7.2.9 Ingress**
    - [ ] Criar `k8s/ingress.yaml`
      - Host: `api.orbitcrm.com`
      - TLS: Cert-manager (Let's Encrypt)
      - Backend: service-api:3333
      - Annotations: NGINX Ingress, rate limiting
  - [ ] **7.2.10 HorizontalPodAutoscaler**
    - [ ] Criar `k8s/hpa-api.yaml`
      - Min replicas: 2
      - Max replicas: 10
      - Target CPU: 70%
      - Scale up/down baseado em m√©tricas
  - [ ] **7.2.11 Criar Scripts de Deploy**
    - [ ] `k8s/deploy-staging.sh`
      - Apply todos manifestos no namespace staging
      - Wait for rollout
    - [ ] `k8s/deploy-prod.sh`
      - Apply com valida√ß√£o
      - Blue-green deployment (zero downtime)
- [ ] üíæ **COMMIT:** `ops: add k8s manifests with api and worker separation`
- [ ] üè∑Ô∏è **TAG:** `git tag -a v0.7.0 -m "Milestone 7: Kubernetes Orchestration"`

---

## üö© Milestone 8: CI/CD & Observabilidade

**Objetivo:** Automa√ß√£o Final e Monitoramento.

- [ ] **8.1 Pipeline CI/CD (GitHub Actions)**
  - [ ] **8.1.1 Criar Workflow de CI**
    - [ ] Criar `.github/workflows/ci.yml`
      - Trigger: push em `main`, `develop` e PRs
      - Jobs:
        1. **Install**: Cache node_modules, install dependencies
        2. **Lint**: Rodar ESLint em server e web
        3. **Type Check**: `tsc --noEmit`
        4. **Test Unit**: Vitest com coverage
        5. **Test E2E Backend**: Testes E2E do NestJS
        6. **Test E2E Frontend**: Playwright headless
        7. **Build**: Compilar TypeScript
      - Matrix strategy: Node 24.x, 22.x
      - Upload coverage para Codecov
  - [ ] **8.1.2 Criar Workflow de CD**
    - [ ] Criar `.github/workflows/cd.yml`
      - Trigger: Tag `v*.*.*`
      - Jobs:
        1. **Build Docker Images**:
           - API: `orbit-crm-api:${{ github.ref_name }}`
           - Worker: `orbit-crm-worker:${{ github.ref_name }}`
           - Frontend: `orbit-crm-web:${{ github.ref_name }}`
        2. **Push to Registry**: Docker Hub ou GHCR
        3. **Deploy to Staging**:
           - Kubectl apply no cluster staging
           - Wait for rollout
           - Run smoke tests
        4. **Deploy to Production** (manual approval):
           - Blue-green deployment
           - Health checks
           - Rollback autom√°tico se falhar
  - [ ] **8.1.3 Configurar Secrets no GitHub**
    - `DOCKER_USERNAME`, `DOCKER_PASSWORD`
    - `KUBECONFIG` (base64 encoded)
    - `CODECOV_TOKEN`
- [ ] **8.2 Docker Builds Otimizados**
  - [ ] **8.2.1 Criar Dockerfile Multi-stage**
    - [ ] Criar `server/Dockerfile`
      - Stage 1 (base): Node Alpine, install dependencies
      - Stage 2 (build): Compilar TypeScript
      - Stage 3 (production-api): Copiar apenas dist + node_modules de produ√ß√£o
      - Stage 4 (production-worker): Mesmo que API, mas CMD diferente
      - Usar BuildKit cache mounts
      - Tamanho final: < 200MB
  - [ ] **8.2.2 Criar Dockerfile Frontend**
    - [ ] Criar `web/Dockerfile`
      - Stage 1: Build (Vite)
      - Stage 2: NGINX Alpine para servir est√°ticos
      - Tamanho final: < 50MB
  - [ ] **8.2.3 Criar .dockerignore**
    - Ignorar: node_modules, dist, .git, .env, coverage
  - [ ] **8.2.4 Configurar Docker Compose Produ√ß√£o**
    - `docker-compose.prod.yml` com imagens buildadas
    - Healthchecks configurados
- [ ] **8.3 Observabilidade Completa**
  - [ ] **8.3.1 Implementar Health Checks**
    - [ ] Criar `server/src/health/health.controller.ts`
      - `GET /health` ‚Üí Liveness probe:
        - Retorna 200 se app est√° rodando
      - `GET /health/ready` ‚Üí Readiness probe:
        - Verifica conex√£o com PostgreSQL
        - Verifica conex√£o com Redis
        - Verifica conex√£o com MinIO
        - Retorna 200 se tudo OK, 503 caso contr√°rio
      - `GET /health/metrics` ‚Üí Prometheus metrics:
        - Request count
        - Response time
        - Active connections
  - [ ] **8.3.2 Configurar Prometheus**
    - Instalar `@willsoto/nestjs-prometheus`
    - Expor m√©tricas em `/metrics`
    - Configurar Prometheus server no K8s
  - [ ] **8.3.3 Configurar Grafana**
    - Deploy Grafana no K8s
    - Dashboards:
      - Requests por segundo
      - Lat√™ncia P50, P95, P99
      - Taxa de erro
      - Uso de mem√≥ria/CPU
      - Queue jobs (pending, completed, failed)
  - [ ] **8.3.4 Configurar Alertas**
    - Alertmanager do Prometheus
    - Alerts:
      - Error rate > 5% ‚Üí Slack/Email
      - Lat√™ncia P95 > 1s ‚Üí Slack/Email
      - Queue com > 1000 jobs pending ‚Üí Slack
      - Pod restart loop ‚Üí PagerDuty
  - [ ] **8.3.5 Distributed Tracing (Opcional)**
    - Jaeger ou OpenTelemetry
    - Rastrear requests entre servi√ßos
    - Visualizar lat√™ncia de cada opera√ß√£o
- [ ] üíæ **COMMIT:** `ci: setup github actions pipeline`
- [ ] üè∑Ô∏è **TAG:** `git tag -a v1.0.0 -m "Release 1.0: Enterprise Gold"`

---

## üí° Features Futuras (Backlog)

- [ ] **Anivers√°rios Autom√°ticos**
  - Cron job di√°rio que verifica anivers√°rios de contatos
  - Envia email/SMS personalizado automaticamente
  - Template customiz√°vel por tenant
  - Dashboard de anivers√°rios do m√™s

- [ ] **Envio de Brindes via Dropshipping**
  - Integra√ß√£o com API de dropshipping (ex: Printful, Giftbit)
  - Cat√°logo de brindes: canecas, camisetas, vouchers
  - Bot√£o "Enviar Brinde" no perfil do contato
  - Workflow: Sele√ß√£o ‚Üí Personaliza√ß√£o ‚Üí Pagamento ‚Üí Envio ‚Üí Tracking
  - Audit log de brindes enviados

pode ser interessante uma feature onde o usuario clica e envia um feliz aniversario direto para o cliente, e tambem pode ser interessante no futuro ter um botao de enviar um mimo via dropshiping
